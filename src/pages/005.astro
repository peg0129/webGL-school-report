---
import Layout from '../layouts/Layout.astro';
---

<Layout title="005">
	<canvas id="webgl-canvas"></canvas>
</Layout>

<style>
	#webgl-canvas{
		display: block;
		margin: 0 auto;
	}
</style>

<script>
	import { WebGLUtility } from '../js/005/webgl.js';

	// ドキュメントの読み込みが完了したら実行されるようイベントを設定する
	window.addEventListener('DOMContentLoaded', () => {
		// アプリケーションのインスタンスを初期化し、必要なリソースをロードする
		const app = new App();
		app.init();
		app.load()
		.then(() => {
			// ジオメトリセットアップ
			app.setupGeometry();
			// ロケーションのセットアップ
			app.setupLocation();

			// セットアップが完了したら描画を開始する
			app.start();
		});
	}, false);

	/**
	 * アプリケーション管理クラス
	 */
	class App {
		/* @types */
		canvas: any;
		gl: any;
		program: any;
		uniformLocation: any;
		position: any;
		positionStride: any;
		positionVBO: any;
		color: any;
		colorStride: any;
		colorVBO: any;
		startTime: any;
		isRender: any;


		/* @constructor */
		constructor() {
			/**
			 * WebGL で描画対象となる canvas
			 * @type {HTMLCanvasElement}
			 */
			this.canvas = null;
			/**
			 * WebGL コンテキスト
			 * @type {WebGLRenderingContext}
			 */
			this.gl = null;
			/**
			 * プログラムオブジェクト
			 * @type {WebGLProgram}
			 */
			this.program = null;
			/**
			 * uniform 変数のロケーションを保持するオブジェクト
			 * @type {object.<WebGLUniformLocation>}
			 */
			this.uniformLocation = null;
			/**
			 * 頂点の座標を格納する配列
			 * @type {Array.<number>}
			 */
			this.position = null;
			/**
			 * 頂点の座標を構成する要素数（ストライド）
			 * @type {number}
			 */
			this.positionStride = null;
			/**
			 * 座標の頂点バッファ
			 * @type {WebGLBuffer}
			 */
			this.positionVBO = null;
			/**
			 * 頂点の色を格納する配列
			 * @type {Array.<number>}
			 */
			this.color = null;
			/**
			 * 頂点の色を構成する要素数（ストライド）
			 * @type {number}
			 */
			this.colorStride = null;
			/**
			 * 色の頂点バッファ
			 * @type {WebGLBuffer}
			 */
			this.colorVBO = null;
			/**
			 * レンダリング開始時のタイムスタンプ
			 * @type {number}
			 */
			this.startTime = null;
			/**
			 * レンダリングを行うかどうかのフラグ
			 * @type {boolean}
			 */
			this.isRender = false;

			// this を固定するためのバインド処理
			this.render = this.render.bind(this);
		}

		/**
		 * 初期化処理を行う
		 */
		init() {
			// canvas エレメントの取得と WebGL コンテキストの初期化
			this.canvas = document.getElementById('webgl-canvas');
			this.gl = WebGLUtility.createWebGLContext(this.canvas);

			// canvas のサイズを設定
			// 解像度確認
			const dpr = window.devicePixelRatio || 1;

			const size = Math.min(window.innerWidth, window.innerHeight);

			// キャンバスの大きさを変更
			this.canvas.width  = size * dpr;
			this.canvas.height = size * dpr;

			// キャンバスのスタイルを変更
			this.canvas.style.width = size + 'px';
    	this.canvas.style.height = size + 'px';
		}

		/**
		 * 各種リソースのロードを行う
		 * @return {Promise}
		 */
		load() {
			let vertUrl;
			let fragtUrl;

			if(location.hostname == '127.0.0.1') {
				vertUrl = '../../public/005-files/shader/main.vert';
				fragtUrl = '../../public/005-files/shader/main.frag';
			} else {
				vertUrl = '../005-files/shader/main.vert';
				fragtUrl = '../005-files/shader/main.frag'
			}

			return new Promise((resolve, reject) => {
				// 変数に WebGL コンテキストを代入しておく（コード記述の最適化）
				const gl = this.gl;
				// WebGL コンテキストがあるかどうか確認する
				if (gl == null) {
					// もし WebGL コンテキストがない場合はエラーとして Promise を reject する
					const error = new Error('not initialized');
					reject(error);
				} else {
					let vs = null;
					let fs = null;
					// まず頂点シェーダのソースコードを読み込む
					WebGLUtility.loadFile(vertUrl)
					.then((vertexShaderSource) => {
						vs = WebGLUtility.createShaderObject(gl, vertexShaderSource, gl.VERTEX_SHADER);
						return WebGLUtility.loadFile(fragtUrl);
					})
					.then((fragmentShaderSource) => {
						fs = WebGLUtility.createShaderObject(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
						this.program = WebGLUtility.createProgramObject(gl, vs, fs);

						// Promise を解決
						resolve();
					});
				}
			});
		}

		/**
		 * 頂点属性（頂点ジオメトリ）のセットアップを行う
		 */
		setupGeometry() {
			// 個数
			const count = 10;
			// 何角形（頂点数）
			const divide = 5;
			// 1角の角度
			const degree = 360 / divide;
			// ラジアンに変換
			const rad = degree * Math.PI / 180;
			// 半径
			const radius = 0.1;
			// 頂点を格納する配列
			const position = [];

			for(let j = 0; j < count; j++){
				// -1 ~ 1のランダムな値
				const randomX = Math.random() * 2 - 1;
				const randomY = Math.random() * 2 - 1;
				// 最初の頂点座標を格納する配列（一番最後の三角形の定義に必要）
				let firstPosition = [];

				for(let i = 0; i < divide; i++){
					// 開始角度を-90°ずらしてx, y座標を算出
					const x = radius * Math.cos((rad * i) - (-90 * Math.PI / 180)) + randomX;  
					const y = radius * Math.sin((rad * i) - (-90 * Math.PI / 180)) + randomY; 
					
					// 一番最後
					if(i == divide - 1){
						position.push(x, y, 0.0);
						position.push(x, y, 0.0);
						position.push(randomX, randomY, 0.0);
						position.push(firstPosition[0], firstPosition[1], firstPosition[2]);
					//一番最初
					} else if(i == 0) {
						position.push(x, y, 0.0);
						position.push(randomX, randomY, 0.0);
						firstPosition.push(x, y, 0.0);
					// それ以外
					} else {
						position.push(x, y, 0.0);
						position.push(x, y, 0.0);
						position.push(randomX, randomY, 0.0);
					}
				}
			}
			// 頂点座標の定義
			this.position = position;
			// 要素数は XYZ の３つ
			this.positionStride = 3;
			// VBO を生成
			this.positionVBO = WebGLUtility.createVBO(this.gl, this.position);

			// 頂点の色情報を格納する配列
			const color = [];
			for(let j = 0; j < count; j++){
				for(let i = 0; i < position.length / this.positionStride; i++){
					color.push(0.0, 0.0, 0.0, 1.0);
				}
			}
			// 頂点の色の定義
			this.color = color;
			// 要素数は RGBA の４つ
			this.colorStride = 4;
			// VBO を生成
			this.colorVBO = WebGLUtility.createVBO(this.gl, this.color);
		}

		/**
		 * 頂点属性のロケーションに関するセットアップを行う
		 */
		setupLocation() {
			const gl = this.gl;
			// attribute location の取得
			const attPosition = gl.getAttribLocation(this.program, 'position');
			const attColor = gl.getAttribLocation(this.program, 'color');
			// attribute location の有効化
			WebGLUtility.enableAttribute(gl, this.positionVBO, attPosition, this.positionStride);
			WebGLUtility.enableAttribute(gl, this.colorVBO, attColor, this.colorStride);

			// uniform location の取得
			this.uniformLocation = {
				time: gl.getUniformLocation(this.program, 'time'),
			};
		}

		/**
		 * レンダリングのためのセットアップを行う
		 */
		setupRendering() {
			const gl = this.gl;
			// ビューポートを設定する
			gl.viewport(0, 0, this.canvas.width, this.canvas.height);
			// クリアする色を設定する（RGBA で 0.0 ～ 1.0 の範囲で指定する）
			gl.clearColor(0.3, 0.3, 0.3, 1.0);
			// 実際にクリアする（gl.COLOR_BUFFER_BIT で色をクリアしろ、という指定になる）
			gl.clear(gl.COLOR_BUFFER_BIT);
		}

		/**
		 * 描画を開始する
		 */
		start() {
			// レンダリング開始時のタイムスタンプを取得しておく
			this.startTime = Date.now();
			// レンダリングを行っているフラグを立てておく
			this.isRender = true;
			// レンダリングの開始
			this.render();
		}

		/**
		 * 描画を停止する
		 */
		stop() {
			this.isRender = false;
		}

		/**
		 * レンダリングを行う
		 */
		render() {
			const gl = this.gl;

			// レンダリングのフラグの状態を見て、requestAnimationFrame を呼ぶか決める
			if (this.isRender === true) {
				requestAnimationFrame(this.render);
			}
			// ビューポートの設定やクリア処理は毎フレーム呼び出す
			this.setupRendering();
			// 現在までの経過時間を計算し、秒単位に変換する
			const nowTime = (Date.now() - this.startTime) * 0.001;
			// プログラムオブジェクトを選択
			gl.useProgram(this.program);

			// ロケーションを指定して、uniform 変数の値を更新する（GPU に送る）
			gl.uniform1f(this.uniformLocation.time, nowTime);
			// ドローコール（描画命令）
			gl.drawArrays(gl.TRIANGLES, 0, this.position.length / this.positionStride);
		}
	}
</script>
